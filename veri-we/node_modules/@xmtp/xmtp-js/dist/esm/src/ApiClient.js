var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
import { messageApi } from '@xmtp/proto';
import { retry, sleep, toNanoString } from './utils';
import AuthCache from './authn/AuthCache';
import { version } from '../package.json';
export const { MessageApi, SortDirection } = messageApi;
const RETRY_SLEEP_TIME = 100;
const ERR_CODE_UNAUTHENTICATED = 16;
const clientVersionHeaderKey = 'X-Client-Version';
const appVersionHeaderKey = 'X-App-Version';
const isAbortError = (err) => {
    if (!err) {
        return false;
    }
    if (err.name === 'AbortError' || err.message.includes('aborted')) {
        return true;
    }
    return false;
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isAuthError = (err) => {
    if (err && err.code === ERR_CODE_UNAUTHENTICATED) {
        return true;
    }
    return false;
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isNotAuthError = (err) => !isAuthError(err);
/**
 * ApiClient provides a wrapper for calling the GRPC Gateway generated code.
 * It adds some helpers for dealing with paginated data and automatically retries idempotent calls
 */
export default class ApiClient {
    constructor(pathPrefix, opts) {
        this.pathPrefix = pathPrefix;
        this.maxRetries = (opts === null || opts === void 0 ? void 0 : opts.maxRetries) || 5;
        this.appVersion = opts === null || opts === void 0 ? void 0 : opts.appVersion;
        this.version = 'xmtp-js/' + version;
    }
    // Raw method for querying the API
    _query(req) {
        return retry(MessageApi.Query, [
            req,
            {
                pathPrefix: this.pathPrefix,
                mode: 'cors',
                headers: this.headers(),
            },
        ], this.maxRetries, RETRY_SLEEP_TIME);
    }
    // Raw method for publishing to the API
    _publish(req, attemptNumber = 0) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const authToken = yield this.getToken();
            const headers = this.headers();
            headers.set('Authorization', `Bearer ${authToken}`);
            try {
                return yield retry(MessageApi.Publish, [
                    req,
                    {
                        pathPrefix: this.pathPrefix,
                        mode: 'cors',
                        headers,
                    },
                ], this.maxRetries, RETRY_SLEEP_TIME, 
                // Do not retry UnauthenticatedErrors
                isNotAuthError);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (e) {
                // Try at most 2X. If refreshing the auth token doesn't work the first time, it won't work the second time
                if (isNotAuthError(e) || attemptNumber >= 1) {
                    throw e;
                }
                yield ((_a = this.authCache) === null || _a === void 0 ? void 0 : _a.refresh());
                return this._publish(req, attemptNumber + 1);
            }
        });
    }
    // Raw method for subscribing
    _subscribe(req, cb) {
        let abortController;
        const doSubscribe = () => {
            abortController = new AbortController();
            const startTime = +new Date();
            MessageApi.Subscribe(req, cb, {
                pathPrefix: this.pathPrefix,
                signal: abortController.signal,
                mode: 'cors',
                headers: this.headers(),
            }).catch((err) => __awaiter(this, void 0, void 0, function* () {
                if (isAbortError(err)) {
                    return;
                }
                console.info('Stream connection lost. Resubscribing', err);
                // If connection was initiated less than 1 second ago, sleep for a bit
                // TODO: exponential backoff + eventually giving up
                if (+new Date() - startTime < 1000) {
                    yield sleep(1000);
                }
                doSubscribe();
            }));
        };
        doSubscribe();
        return () => __awaiter(this, void 0, void 0, function* () {
            abortController === null || abortController === void 0 ? void 0 : abortController.abort();
        });
    }
    // Use the Query API to return the full contents of any specified topics
    query(params, { direction = SortDirection.SORT_DIRECTION_ASCENDING, limit, }) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            const out = [];
            try {
                // Use queryIteratePages for better performance. 1/100th the number of Promises to resolve compared to queryStream
                for (var _b = __asyncValues(this.queryIteratePages(params, {
                    direction,
                    // If there is a limit of < 100, use that as the page size. Otherwise use 100 and stop if/when limit reached.
                    pageSize: limit && limit < 100 ? limit : 100,
                })), _c; _c = yield _b.next(), !_c.done;) {
                    const page = _c.value;
                    for (const envelope of page) {
                        out.push(envelope);
                        if (limit && out.length === limit) {
                            return out;
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return out;
        });
    }
    // Will produce an AsyncGenerator of Envelopes
    // Uses queryStreamPages under the hood
    queryIterator(params, options) {
        return __asyncGenerator(this, arguments, function* queryIterator_1() {
            var e_2, _a;
            try {
                for (var _b = __asyncValues(this.queryIteratePages(params, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const envelope of page) {
                        yield yield __await(envelope);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    // Creates an async generator that will paginate through the Query API until it reaches the end
    // Will yield each page of results as needed
    queryIteratePages({ contentTopics, startTime, endTime }, { direction, pageSize = 10 }) {
        var _a, _b, _c;
        return __asyncGenerator(this, arguments, function* queryIteratePages_1() {
            if (!contentTopics || !contentTopics.length) {
                throw new Error('Must specify content topics');
            }
            const startTimeNs = toNanoString(startTime);
            const endTimeNs = toNanoString(endTime);
            let cursor;
            while (true) {
                const pagingInfo = {
                    limit: pageSize,
                    direction,
                    cursor,
                };
                const result = yield __await(this._query({
                    contentTopics,
                    startTimeNs,
                    endTimeNs,
                    pagingInfo,
                }));
                if ((_a = result.envelopes) === null || _a === void 0 ? void 0 : _a.length) {
                    yield yield __await(result.envelopes);
                }
                else {
                    return yield __await(void 0);
                }
                if ((_b = result.pagingInfo) === null || _b === void 0 ? void 0 : _b.cursor) {
                    cursor = (_c = result.pagingInfo) === null || _c === void 0 ? void 0 : _c.cursor;
                }
                else {
                    return yield __await(void 0);
                }
            }
        });
    }
    // Publish a message to the network
    // Will convert timestamps to the appropriate format expected by the network
    publish(messages) {
        return __awaiter(this, void 0, void 0, function* () {
            const toSend = [];
            for (const { contentTopic, message, timestamp } of messages) {
                if (!contentTopic.length) {
                    throw new Error('Content topic cannot be empty string');
                }
                if (!message.length) {
                    throw new Error('0 length messages not allowed');
                }
                const dt = timestamp || new Date();
                toSend.push({
                    contentTopic,
                    timestampNs: toNanoString(dt),
                    message: Uint8Array.from(message),
                });
            }
            return this._publish({ envelopes: toSend });
        });
    }
    // Subscribe to a list of topics.
    // Provided callback function will be called on each new message
    // Returns an unsubscribe function that can be used to end the subscription
    subscribe(params, callback) {
        if (!params.contentTopics.length) {
            throw new Error('Must provide list of contentTopics to subscribe to');
        }
        return this._subscribe(params, callback);
    }
    getToken() {
        if (!this.authCache) {
            throw new Error('AuthCache is not set on API Client');
        }
        return this.authCache.getToken();
    }
    setAuthenticator(authenticator, cacheExpirySeconds) {
        this.authCache = new AuthCache(authenticator, cacheExpirySeconds);
    }
    headers() {
        const headers = new Headers();
        headers.set(clientVersionHeaderKey, this.version);
        if (this.appVersion) {
            headers.set(appVersionHeaderKey, this.appVersion);
        }
        return headers;
    }
}
//# sourceMappingURL=ApiClient.js.map