"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const PublicKeyBundle_1 = require("./../crypto/PublicKeyBundle");
const Conversation_1 = require("./Conversation");
const Message_1 = require("../Message");
const Stream_1 = __importDefault(require("../Stream"));
const utils_1 = require("../utils");
const Invitation_1 = require("../Invitation");
const crypto_1 = require("../crypto");
const proto_1 = require("@xmtp/proto");
const { b64Decode } = proto_1.fetcher;
const messageHasHeaders = (msg) => {
    return Boolean(msg.recipientAddress && msg.senderAddress);
};
/**
 * Conversations allows you to view ongoing 1:1 messaging sessions with another wallet
 */
class Conversations {
    constructor(client) {
        this.client = client;
    }
    /**
     * List all conversations with the current wallet found in the network, deduped by peer address
     */
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            const [seenPeers, invitations] = yield Promise.all([
                this.getIntroductionPeers(),
                this.client.listInvitations(),
            ]);
            const conversations = [];
            seenPeers.forEach((sent, peerAddress) => conversations.push(new Conversation_1.ConversationV1(this.client, peerAddress, sent)));
            for (const sealed of invitations) {
                try {
                    const unsealed = yield sealed.v1.getInvitation(this.client.keys);
                    conversations.push(yield Conversation_1.ConversationV2.create(this.client, unsealed, sealed.v1.header));
                }
                catch (e) {
                    console.warn('Error decrypting invitation', e);
                }
            }
            conversations.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());
            return conversations;
        });
    }
    /**
     * Returns a stream of any newly created conversations.
     * Will dedupe to not return the same conversation twice in the same stream.
     * Does not dedupe any other previously seen conversations
     */
    stream() {
        return __awaiter(this, void 0, void 0, function* () {
            const seenPeers = new Set();
            const introTopic = (0, utils_1.buildUserIntroTopic)(this.client.address);
            const inviteTopic = (0, utils_1.buildUserInviteTopic)(this.client.address);
            const newPeer = (peerAddress) => {
                // Check if we have seen the peer already in this stream
                if (seenPeers.has(peerAddress)) {
                    return false;
                }
                seenPeers.add(peerAddress);
                return true;
            };
            const decodeConversation = (env) => __awaiter(this, void 0, void 0, function* () {
                if (env.contentTopic === introTopic) {
                    const messageBytes = b64Decode(env.message);
                    const msg = yield Message_1.MessageV1.fromBytes(messageBytes);
                    yield msg.decrypt(this.client.legacyKeys);
                    const peerAddress = this.getPeerAddress(msg);
                    if (!newPeer(peerAddress)) {
                        return undefined;
                    }
                    return new Conversation_1.ConversationV1(this.client, peerAddress, msg.sent);
                }
                if (env.contentTopic === inviteTopic) {
                    const sealed = yield Invitation_1.SealedInvitation.fromEnvelope(env);
                    const unsealed = yield sealed.v1.getInvitation(this.client.keys);
                    return yield Conversation_1.ConversationV2.create(this.client, unsealed, sealed.v1.header);
                }
                throw new Error('unrecognized invite topic');
            });
            return Stream_1.default.create(this.client, [inviteTopic, introTopic], decodeConversation.bind(this));
        });
    }
    /**
     * Streams messages from all conversations.
     *
     * When a new conversation is initiated with the client's address, this function will automatically register it and add it to the list of conversations to watch.
     * Callers should be aware the first messages in a newly created conversation are picked up on a best effort basis and there are other potential race conditions which may cause some newly created conversations to be missed.
     *
     */
    streamAllMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            const introTopic = (0, utils_1.buildUserIntroTopic)(this.client.address);
            const inviteTopic = (0, utils_1.buildUserInviteTopic)(this.client.address);
            const topics = new Set([introTopic, inviteTopic]);
            const convoMap = new Map();
            for (const conversation of yield this.list()) {
                topics.add(conversation.topic);
                convoMap.set(conversation.topic, conversation);
            }
            const decodeMessage = (env) => __awaiter(this, void 0, void 0, function* () {
                const contentTopic = env.contentTopic;
                if (!contentTopic) {
                    return null;
                }
                if (contentTopic === introTopic) {
                    const messageBytes = b64Decode(env.message);
                    const msg = yield Message_1.MessageV1.fromBytes(messageBytes);
                    if (!messageHasHeaders(msg)) {
                        return null;
                    }
                    // Decrypt the message to ensure it hasn't been spoofed
                    yield msg.decrypt(this.client.legacyKeys);
                    const peerAddress = msg.senderAddress === this.client.address
                        ? msg.recipientAddress
                        : msg.senderAddress;
                    // Temporarily create a convo to decrypt the message
                    const convo = new Conversation_1.ConversationV1(this.client, peerAddress, msg.sent);
                    return convo.decodeMessage(env);
                }
                // Decode as an invite and return the envelope
                // This gives the contentTopicUpdater everything it needs to add to the topic list
                if (contentTopic === inviteTopic) {
                    const sealed = yield Invitation_1.SealedInvitation.fromEnvelope(env);
                    const unsealed = yield sealed.v1.getInvitation(this.client.keys);
                    return Conversation_1.ConversationV2.create(this.client, unsealed, sealed.v1.header);
                }
                const convo = convoMap.get(contentTopic);
                // Decode as a V1 message if the topic matches a V1 convo
                if (convo instanceof Conversation_1.ConversationV1) {
                    return convo.decodeMessage(env);
                }
                // Decode as a V2 message if the topic matches a V2 convo
                if (convo instanceof Conversation_1.ConversationV2) {
                    return convo.decodeMessage(env);
                }
                console.log('Unknown topic');
                throw new Error('Unknown topic');
            });
            const addConvo = (topic, conversation) => {
                if (topics.has(topic)) {
                    return false;
                }
                convoMap.set(topic, conversation);
                topics.add(topic);
                return true;
            };
            const contentTopicUpdater = (msg) => {
                // If we have a V1 message from the introTopic, store the conversation in our mapping
                if (msg instanceof Message_1.DecodedMessage && msg.contentTopic === introTopic) {
                    const convo = new Conversation_1.ConversationV1(this.client, msg.recipientAddress === this.client.address
                        ? msg.senderAddress
                        : msg.recipientAddress, msg.sent);
                    const isNew = addConvo(convo.topic, convo);
                    return isNew ? Array.from(topics.values()) : undefined;
                }
                if (msg instanceof Conversation_1.ConversationV2) {
                    const isNew = addConvo(msg.topic, msg);
                    return isNew ? Array.from(topics.values()) : undefined;
                }
                return undefined;
            };
            const str = yield Stream_1.default.create(this.client, Array.from(topics.values()), decodeMessage, contentTopicUpdater);
            return (function generate() {
                return __asyncGenerator(this, arguments, function* generate_1() {
                    var e_1, _a;
                    try {
                        for (var str_1 = __asyncValues(str), str_1_1; str_1_1 = yield __await(str_1.next()), !str_1_1.done;) {
                            const val = str_1_1.value;
                            if (val instanceof Message_1.DecodedMessage) {
                                yield yield __await(val);
                            }
                            // For conversation V2, we may have messages in the new topic before we started streaming.
                            // To be safe, we fetch all messages
                            if (val instanceof Conversation_1.ConversationV2) {
                                for (const convoMessage of yield __await(val.messages())) {
                                    yield yield __await(convoMessage);
                                }
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) yield __await(_a.call(str_1));
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                });
            })();
        });
    }
    getIntroductionPeers() {
        return __awaiter(this, void 0, void 0, function* () {
            const messages = yield this.client.listEnvelopes([(0, utils_1.buildUserIntroTopic)(this.client.address)], (env) => __awaiter(this, void 0, void 0, function* () {
                const msg = yield Message_1.MessageV1.fromBytes(b64Decode(env.message));
                // Decrypt the message to ensure it is valid. Ignore the contents
                yield msg.decrypt(this.client.legacyKeys);
                return msg;
            }));
            const seenPeers = new Map();
            for (const message of messages) {
                // Ignore all messages without sender or recipient address headers
                // Makes getPeerAddress safe
                if (!messageHasHeaders(message)) {
                    continue;
                }
                const peerAddress = this.getPeerAddress(message);
                if (peerAddress) {
                    const have = seenPeers.get(peerAddress);
                    if (!have || have > message.sent) {
                        seenPeers.set(peerAddress, message.sent);
                    }
                }
            }
            return seenPeers;
        });
    }
    /**
     * Creates a new conversation for the given address. Will throw an error if the peer is not found in the XMTP network
     */
    newConversation(peerAddress, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let contact = yield this.client.getUserContact(peerAddress);
            if (!contact) {
                throw new Error(`Recipient ${peerAddress} is not on the XMTP network`);
            }
            // If this is a V1 conversation continuation
            if (contact instanceof crypto_1.PublicKeyBundle && !(context === null || context === void 0 ? void 0 : context.conversationId)) {
                return new Conversation_1.ConversationV1(this.client, peerAddress, new Date());
            }
            if (!(context === null || context === void 0 ? void 0 : context.conversationId)) {
                const intros = yield this.getIntroductionPeers();
                const introSentTime = intros.get(peerAddress);
                // If intro already exists, return V1 conversation
                if (introSentTime) {
                    return new Conversation_1.ConversationV1(this.client, peerAddress, introSentTime);
                }
            }
            // Coerce the contact into a V2 bundle
            if (contact instanceof crypto_1.PublicKeyBundle) {
                contact = PublicKeyBundle_1.SignedPublicKeyBundle.fromLegacyBundle(contact);
            }
            for (const sealedInvite of yield this.client.listInvitations()) {
                const isSamePeer = sealedInvite.v1.header.recipient.equals(contact) ||
                    sealedInvite.v1.header.sender.equals(contact);
                if (!isSamePeer) {
                    continue;
                }
                try {
                    // Need to decode invite even without a context to ensure decryption succeeds and invite is valid
                    const invite = yield sealedInvite.v1.getInvitation(this.client.keys);
                    // If the contexts match, return early
                    if (isMatchingContext(context, invite.context)) {
                        return yield Conversation_1.ConversationV2.create(this.client, invite, sealedInvite.v1.header);
                    }
                }
                catch (e) {
                    console.warn('Error decoding invite', e);
                }
            }
            // If no existing invite, send a new one
            const invitation = Invitation_1.InvitationV1.createRandom(context);
            const sealedInvite = yield this.sendInvitation(contact, invitation, new Date());
            return Conversation_1.ConversationV2.create(this.client, invitation, sealedInvite.v1.header);
        });
    }
    sendInvitation(recipient, invitation, created) {
        return __awaiter(this, void 0, void 0, function* () {
            const sealed = yield Invitation_1.SealedInvitation.createV1({
                sender: this.client.keys,
                recipient,
                created,
                invitation,
            });
            const peerAddress = yield recipient.walletSignatureAddress();
            this.client.publishEnvelopes([
                {
                    contentTopic: (0, utils_1.buildUserInviteTopic)(peerAddress),
                    message: sealed.toBytes(),
                    timestamp: created,
                },
                {
                    contentTopic: (0, utils_1.buildUserInviteTopic)(this.client.address),
                    message: sealed.toBytes(),
                    timestamp: created,
                },
            ]);
            return sealed;
        });
    }
    getPeerAddress(message) {
        const peerAddress = message.recipientAddress === this.client.address
            ? message.senderAddress
            : message.recipientAddress;
        // This assertion is safe, so long as messages have been through the filter
        return peerAddress;
    }
}
exports.default = Conversations;
function isMatchingContext(contextA, contextB) {
    // Use == to allow null and undefined to be equivalent
    return (contextA === null || contextA === void 0 ? void 0 : contextA.conversationId) === (contextB === null || contextB === void 0 ? void 0 : contextB.conversationId);
}
//# sourceMappingURL=Conversations.js.map