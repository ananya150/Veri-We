"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationV2 = exports.ConversationV1 = void 0;
const utils_1 = require("./../utils");
const Message_1 = require("./../Message");
const Stream_1 = __importDefault(require("../Stream"));
const Message_2 = require("../Message");
const proto_1 = require("@xmtp/proto");
const crypto_1 = require("../crypto");
const Ciphertext_1 = __importDefault(require("../crypto/Ciphertext"));
const encryption_1 = require("../crypto/encryption");
const utils_2 = require("../utils");
const Text_1 = require("../codecs/Text");
const { b64Decode } = proto_1.fetcher;
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/**
 * Conversation class allows you to view, stream, and send messages to/from a peer address
 */
class ConversationV1 {
    constructor(client, address, createdAt) {
        this.context = null;
        this.peerAddress = address;
        this.client = client;
        this.createdAt = createdAt;
    }
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    messages(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const topics = [
                (0, utils_2.buildDirectMessageTopic)(this.peerAddress, this.client.address),
            ];
            return this.client.listEnvelopes(topics, this.decodeMessage.bind(this), opts);
        });
    }
    get topic() {
        return (0, utils_2.buildDirectMessageTopic)(this.peerAddress, this.client.address);
    }
    messagesPaginated(opts) {
        return this.client.listEnvelopesPaginated([this.topic], this.decodeMessage.bind(this), opts);
    }
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages() {
        return Stream_1.default.create(this.client, [this.topic], this.decodeMessage.bind(this));
    }
    decodeMessage({ message, contentTopic, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const messageBytes = proto_1.fetcher.b64Decode(message);
            const decoded = yield Message_2.MessageV1.fromBytes(messageBytes);
            const { senderAddress, recipientAddress } = decoded;
            // Filter for topics
            if (!senderAddress ||
                !recipientAddress ||
                !contentTopic ||
                (0, utils_2.buildDirectMessageTopic)(senderAddress, recipientAddress) !== this.topic) {
                throw new Error('Headers do not match intended recipient');
            }
            const decrypted = yield decoded.decrypt(this.client.legacyKeys);
            const { content, contentType, error } = (0, Message_2.decodeContent)(decrypted, this.client);
            return Message_1.DecodedMessage.fromV1Message(decoded, content, contentType, contentTopic, this, error);
        });
    }
    /**
     * Send a message into the conversation
     */
    send(content, // eslint-disable-line @typescript-eslint/no-explicit-any
    options) {
        return __awaiter(this, void 0, void 0, function* () {
            let topics;
            const recipient = yield this.client.getUserContact(this.peerAddress);
            if (!recipient) {
                throw new Error(`recipient ${this.peerAddress} is not registered`);
            }
            if (!(recipient instanceof crypto_1.PublicKeyBundle)) {
                throw new Error(`recipient bundle is not legacy bundle`);
            }
            if (!this.client.contacts.has(this.peerAddress)) {
                topics = [
                    (0, utils_1.buildUserIntroTopic)(this.peerAddress),
                    (0, utils_1.buildUserIntroTopic)(this.client.address),
                    this.topic,
                ];
                this.client.contacts.add(this.peerAddress);
            }
            else {
                topics = [this.topic];
            }
            const contentType = (options === null || options === void 0 ? void 0 : options.contentType) || Text_1.ContentTypeText;
            const timestamp = (options === null || options === void 0 ? void 0 : options.timestamp) || new Date();
            const payload = yield this.client.encodeContent(content, options);
            const msg = yield Message_2.MessageV1.encode(this.client.legacyKeys, recipient, payload, timestamp);
            yield this.client.publishEnvelopes(topics.map((topic) => ({
                contentTopic: topic,
                message: msg.toBytes(),
                timestamp: msg.sent,
            })));
            return Message_1.DecodedMessage.fromV1Message(msg, content, contentType, topics[0], // Just use the first topic for the returned value
            this);
        });
    }
}
exports.ConversationV1 = ConversationV1;
class ConversationV2 {
    constructor(client, invitation, header, peerAddress) {
        this.topic = invitation.topic;
        this.keyMaterial = invitation.aes256GcmHkdfSha256.keyMaterial;
        this.context = invitation.context;
        this.client = client;
        this.header = header;
        this.peerAddress = peerAddress;
    }
    static create(client, invitation, header) {
        return __awaiter(this, void 0, void 0, function* () {
            const myKeys = client.keys.getPublicKeyBundle();
            const peer = myKeys.equals(header.sender) ? header.recipient : header.sender;
            const peerAddress = yield peer.walletSignatureAddress();
            return new ConversationV2(client, invitation, header, peerAddress);
        });
    }
    get createdAt() {
        return (0, utils_2.nsToDate)(this.header.createdNs);
    }
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    messages(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.listEnvelopes([this.topic], this.decodeMessage.bind(this), opts);
        });
    }
    messagesPaginated(opts) {
        return this.client.listEnvelopesPaginated([this.topic], this.decodeMessage.bind(this), opts);
    }
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages() {
        return Stream_1.default.create(this.client, [this.topic], this.decodeMessage.bind(this));
    }
    /**
     * Send a message into the conversation
     */
    send(content, // eslint-disable-line @typescript-eslint/no-explicit-any
    options) {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = yield this.encodeMessage(content, options);
            yield this.client.publishEnvelopes([
                {
                    contentTopic: this.topic,
                    message: msg.toBytes(),
                    timestamp: msg.sent,
                },
            ]);
            const contentType = (options === null || options === void 0 ? void 0 : options.contentType) || Text_1.ContentTypeText;
            return Message_1.DecodedMessage.fromV2Message(msg, content, contentType, this.topic, this);
        });
    }
    encodeMessage(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    content, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = yield this.client.encodeContent(content, options);
            const header = {
                topic: this.topic,
                createdNs: (0, utils_2.dateToNs)((options === null || options === void 0 ? void 0 : options.timestamp) || new Date()),
            };
            const headerBytes = proto_1.xmtpEnvelope.MessageHeaderV2.encode(header).finish();
            const digest = yield (0, encryption_1.sha256)(concat(headerBytes, payload));
            const signed = {
                payload,
                sender: this.client.keys.getPublicKeyBundle(),
                signature: yield this.client.keys.getCurrentPreKey().sign(digest),
            };
            const signedBytes = proto_1.xmtpEnvelope.SignedContent.encode(signed).finish();
            const ciphertext = yield (0, crypto_1.encrypt)(signedBytes, this.keyMaterial, headerBytes);
            const protoMsg = {
                v1: undefined,
                v2: { headerBytes, ciphertext },
            };
            const bytes = proto_1.xmtpEnvelope.Message.encode(protoMsg).finish();
            return Message_2.MessageV2.create(protoMsg, header, signed, bytes);
        });
    }
    decodeMessage(env) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (!env.message || !env.contentTopic) {
                throw new Error('empty envelope');
            }
            const messageBytes = b64Decode(env.message.toString());
            const msg = proto_1.xmtpEnvelope.Message.decode(messageBytes);
            if (!msg.v2) {
                throw new Error('unknown message version');
            }
            const msgv2 = msg.v2;
            const header = proto_1.xmtpEnvelope.MessageHeaderV2.decode(msgv2.headerBytes);
            if (header.topic !== this.topic) {
                throw new Error('topic mismatch');
            }
            if (!msgv2.ciphertext) {
                throw new Error('missing ciphertext');
            }
            const decrypted = yield (0, crypto_1.decrypt)(new Ciphertext_1.default(msgv2.ciphertext), this.keyMaterial, msgv2.headerBytes);
            const signed = proto_1.xmtpEnvelope.SignedContent.decode(decrypted);
            if (!((_a = signed.sender) === null || _a === void 0 ? void 0 : _a.identityKey) ||
                !((_b = signed.sender) === null || _b === void 0 ? void 0 : _b.preKey) ||
                !signed.signature) {
                throw new Error('incomplete signed content');
            }
            const digest = yield (0, encryption_1.sha256)(concat(msgv2.headerBytes, signed.payload));
            if (!new crypto_1.SignedPublicKey((_c = signed.sender) === null || _c === void 0 ? void 0 : _c.preKey).verify(new crypto_1.Signature(signed.signature), digest)) {
                throw new Error('invalid signature');
            }
            const message = yield Message_2.MessageV2.create(msg, header, signed, messageBytes);
            const { content, contentType, error } = (0, Message_2.decodeContent)(signed.payload, this.client);
            return Message_1.DecodedMessage.fromV2Message(message, content, contentType, env.contentTopic, this, error);
        });
    }
}
exports.ConversationV2 = ConversationV2;
function concat(a, b) {
    const ab = new Uint8Array(a.length + b.length);
    ab.set(a);
    ab.set(b, a.length);
    return ab;
}
//# sourceMappingURL=Conversation.js.map