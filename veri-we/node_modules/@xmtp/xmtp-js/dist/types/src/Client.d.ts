import { PublicKeyBundle, SignedPublicKeyBundle, PrivateKeyBundleV1, PrivateKeyBundleV2 } from './crypto';
import { EnvelopeMapper } from './utils';
import { Signer } from 'ethers';
import { Conversations } from './conversations';
import { ContentTypeId, ContentCodec } from './MessageContent';
import { xmtpEnvelope, messageApi } from '@xmtp/proto';
import ApiClient, { PublishParams } from './ApiClient';
import { SealedInvitation } from './Invitation';
declare const Compression: typeof xmtpEnvelope.Compression;
export declare const ApiUrls: {
    readonly local: "http://localhost:5555";
    readonly dev: "https://dev.xmtp.network";
    readonly production: "https://production.xmtp.network";
};
export declare type ListMessagesOptions = {
    checkAddresses?: boolean;
    startTime?: Date;
    endTime?: Date;
    limit?: number;
    direction?: messageApi.SortDirection;
};
export declare type ListMessagesPaginatedOptions = {
    startTime?: Date;
    endTime?: Date;
    pageSize?: number;
    direction?: messageApi.SortDirection;
};
export declare enum KeyStoreType {
    networkTopicStoreV1 = 0,
    static = 1
}
export { Compression };
export declare type SendOptions = {
    contentType?: ContentTypeId;
    contentFallback?: string;
    compression?: xmtpEnvelope.Compression;
    timestamp?: Date;
};
/**
 * Network startup options
 */
declare type NetworkOptions = {
    env: keyof typeof ApiUrls;
    apiUrl: string | undefined;
    appVersion?: string;
};
declare type ContentOptions = {
    codecs: ContentCodec<any>[];
    maxContentSize: number;
};
declare type KeyStoreOptions = {
    /** Specify the keyStore which should be used for loading or saving privateKeyBundles */
    keyStoreType: KeyStoreType;
    privateKeyOverride?: Uint8Array;
};
/**
 * Aggregate type for client options. Optional properties are used when the default value is calculated on invocation, and are computed
 * as needed by each function. All other defaults are specified in defaultOptions.
 */
export declare type ClientOptions = NetworkOptions & KeyStoreOptions & ContentOptions;
/**
 * Provide a default client configuration. These settings can be used on their own, or as a starting point for custom configurations
 *
 * @param opts additional options to override the default settings
 */
export declare function defaultOptions(opts?: Partial<ClientOptions>): ClientOptions;
/**
 * Client class initiates connection to the XMTP network.
 * Should be created with `await Client.create(options)`
 */
export default class Client {
    address: string;
    legacyKeys: PrivateKeyBundleV1;
    keys: PrivateKeyBundleV2;
    apiClient: ApiClient;
    contacts: Set<string>;
    private knownPublicKeyBundles;
    private _conversations;
    private _codecs;
    private _maxContentSize;
    constructor(keys: PrivateKeyBundleV1, apiClient: ApiClient);
    /**
     * @type {Conversations}
     */
    get conversations(): Conversations;
    /**
     * Create and start a client associated with given wallet.
     *
     * @param wallet the wallet as a Signer instance
     * @param opts specify how to to connect to the network
     */
    static create(wallet: Signer | null, opts?: Partial<ClientOptions>): Promise<Client>;
    static getKeys(wallet: Signer | null, opts?: Partial<ClientOptions>): Promise<Uint8Array>;
    init(options: ClientOptions): Promise<void>;
    close(): Promise<void>;
    publishUserContact(legacy?: boolean): Promise<void>;
    /**
     * Returns the cached PublicKeyBundle if one is known for the given address or fetches
     * one from the network
     */
    getUserContact(peerAddress: string): Promise<PublicKeyBundle | SignedPublicKeyBundle | undefined>;
    forgetContact(peerAddress: string): void;
    /**
     * Check if @peerAddress can be messaged, specifically it checks that a PublicKeyBundle can be
     * found for the given address
     */
    canMessage(peerAddress: string): Promise<boolean>;
    static canMessage(peerAddress: string, opts?: Partial<NetworkOptions>): Promise<boolean>;
    private validateEnvelope;
    publishEnvelopes(envelopes: PublishParams[]): Promise<void>;
    registerCodec(codec: ContentCodec<any>): void;
    codecFor(contentType: ContentTypeId): ContentCodec<any> | undefined;
    encodeContent(content: any, options?: SendOptions): Promise<Uint8Array>;
    listInvitations(opts?: ListMessagesOptions): Promise<SealedInvitation[]>;
    listEnvelopes<Out>(topics: string[], mapper: EnvelopeMapper<Out>, opts?: ListMessagesOptions): Promise<Out[]>;
    /**
     * List messages on a given set of content topics, yielding one page at a time
     */
    listEnvelopesPaginated<Out>(contentTopics: string[], mapper: EnvelopeMapper<Out>, opts?: ListMessagesPaginatedOptions): AsyncGenerator<Out[]>;
}
