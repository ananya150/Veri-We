import { DecodedMessage } from './../Message';
import Stream from '../Stream';
import Client, { ListMessagesOptions, ListMessagesPaginatedOptions, SendOptions } from '../Client';
import { InvitationContext, InvitationV1, SealedInvitationHeaderV1 } from '../Invitation';
import { messageApi } from '@xmtp/proto';
/**
 * Conversation class allows you to view, stream, and send messages to/from a peer address
 */
export declare class ConversationV1 {
    peerAddress: string;
    createdAt: Date;
    context: null;
    private client;
    constructor(client: Client, address: string, createdAt: Date);
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    messages(opts?: ListMessagesOptions): Promise<DecodedMessage[]>;
    get topic(): string;
    messagesPaginated(opts?: ListMessagesPaginatedOptions): AsyncGenerator<DecodedMessage[]>;
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages(): Promise<Stream<DecodedMessage>>;
    decodeMessage({ message, contentTopic, }: messageApi.Envelope): Promise<DecodedMessage>;
    /**
     * Send a message into the conversation
     */
    send(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<DecodedMessage>;
}
export declare class ConversationV2 {
    topic: string;
    keyMaterial: Uint8Array;
    context?: InvitationContext;
    private header;
    private client;
    peerAddress: string;
    constructor(client: Client, invitation: InvitationV1, header: SealedInvitationHeaderV1, peerAddress: string);
    static create(client: Client, invitation: InvitationV1, header: SealedInvitationHeaderV1): Promise<ConversationV2>;
    get createdAt(): Date;
    /**
     * Returns a list of all messages to/from the peerAddress
     */
    messages(opts?: ListMessagesOptions): Promise<DecodedMessage[]>;
    messagesPaginated(opts?: ListMessagesPaginatedOptions): AsyncGenerator<DecodedMessage[]>;
    /**
     * Returns a Stream of any new messages to/from the peerAddress
     */
    streamMessages(): Promise<Stream<DecodedMessage>>;
    /**
     * Send a message into the conversation
     */
    send(content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    options?: SendOptions): Promise<DecodedMessage>;
    private encodeMessage;
    decodeMessage(env: messageApi.Envelope): Promise<DecodedMessage>;
}
export declare type Conversation = ConversationV1 | ConversationV2;
