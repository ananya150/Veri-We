import { messageApi } from '@xmtp/proto';
import { NotifyStreamEntityArrival } from '@xmtp/proto/ts/dist/types/fetch.pb';
import { Authenticator } from './authn';
export declare const MessageApi: typeof messageApi.MessageApi, SortDirection: typeof messageApi.SortDirection;
export declare type GrpcError = Error & {
    code?: number;
};
export declare type QueryParams = {
    startTime?: Date;
    endTime?: Date;
    contentTopics: string[];
};
export declare type QueryAllOptions = {
    direction?: messageApi.SortDirection;
    limit?: number;
};
export declare type QueryStreamOptions = Omit<QueryAllOptions, 'limit'> & {
    pageSize?: number;
};
export declare type PublishParams = {
    contentTopic: string;
    message: Uint8Array;
    timestamp?: Date;
};
export declare type SubscribeParams = {
    contentTopics: string[];
};
export declare type ApiClientOptions = {
    maxRetries?: number;
    appVersion?: string;
};
export declare type SubscribeCallback = NotifyStreamEntityArrival<messageApi.Envelope>;
export declare type UnsubscribeFn = () => Promise<void>;
/**
 * ApiClient provides a wrapper for calling the GRPC Gateway generated code.
 * It adds some helpers for dealing with paginated data and automatically retries idempotent calls
 */
export default class ApiClient {
    pathPrefix: string;
    maxRetries: number;
    private authCache?;
    appVersion: string | undefined;
    version: string;
    constructor(pathPrefix: string, opts?: ApiClientOptions);
    private _query;
    private _publish;
    private _subscribe;
    query(params: QueryParams, { direction, limit, }: QueryAllOptions): Promise<messageApi.Envelope[]>;
    queryIterator(params: QueryParams, options: QueryStreamOptions): AsyncGenerator<messageApi.Envelope>;
    queryIteratePages({ contentTopics, startTime, endTime }: QueryParams, { direction, pageSize }: QueryStreamOptions): AsyncGenerator<messageApi.Envelope[]>;
    publish(messages: PublishParams[]): ReturnType<typeof MessageApi.Publish>;
    subscribe(params: SubscribeParams, callback: SubscribeCallback): UnsubscribeFn;
    private getToken;
    setAuthenticator(authenticator: Authenticator, cacheExpirySeconds?: number): void;
    headers(): Headers;
}
