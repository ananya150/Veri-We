{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createInternalPostHogInstance = void 0;\nconst package_json_1 = require(\"../package.json\");\nconst utils_1 = require(\"./utils/utils\");\nconst context_1 = require(\"./utils/context\");\nconst lz_string_js_1 = require(\"./utils/lz-string.js\");\nconst defaultOptions = {\n  apiHost: 'https://app.posthog.com',\n  maxQueueLength: 1,\n  optedIn: true\n};\nfunction createInternalPostHogInstance(apiKey, options, globalThis) {\n  const session = {};\n  const anonymousId = utils_1.generateUUID(globalThis);\n  let postHogInstance = {\n    options: Object.assign(Object.assign(Object.assign({}, defaultOptions), options), {\n      apiKey\n    }),\n    session: Object.assign({\n      anonymousId: anonymousId,\n      distinctId: anonymousId\n    }, session),\n    getDistinctId() {\n      return postHogInstance.session.distinctId;\n    },\n    getContextProperties() {\n      return {\n        $lib: 'posthog-js-lite',\n        $lib_version: package_json_1.version\n      };\n    },\n    optedIn() {\n      return postHogInstance.options.optedIn;\n    },\n    optIn() {\n      postHogInstance.options.optedIn = true;\n      postHogInstance.flush();\n    },\n    optOut() {\n      postHogInstance.options.optedIn = false;\n    },\n    capture(event) {\n      let properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      postHogInstance.enqueue({\n        event,\n        distinct_id: postHogInstance.getDistinctId(),\n        timestamp: utils_1.currentISOTime(),\n        properties: Object.assign(Object.assign({}, context_1.getContext(globalThis)), properties)\n      });\n    },\n    identify(distinctId) {\n      let userProperties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      postHogInstance.enqueue({\n        event: '$identify',\n        distinct_id: distinctId || postHogInstance.session.anonymousId,\n        timestamp: utils_1.currentISOTime(),\n        $set: Object.assign({}, userProperties),\n        properties: Object.assign(Object.assign({}, context_1.getContext(globalThis)), {\n          $anon_distinct_id: postHogInstance.session.anonymousId\n        })\n      });\n      if (distinctId) {\n        postHogInstance.session.distinctId = distinctId;\n      }\n    },\n    queue: [],\n    enqueue(apiRequest) {\n      postHogInstance.queue.push(apiRequest);\n      if (postHogInstance.optedIn() && postHogInstance.queue.length >= postHogInstance.options.maxQueueLength) {\n        postHogInstance.flush();\n      }\n    },\n    flush() {\n      let queue = postHogInstance.queue;\n      postHogInstance.queue = [];\n      postHogInstance.makeRequest(queue);\n    },\n    makeRequest: function (events) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const requestData = {\n          api_key: postHogInstance.options.apiKey,\n          batch: events,\n          sent_at: utils_1.currentISOTime()\n        };\n        const url = `${postHogInstance.options.apiHost}/e/?ip=1&_=${utils_1.currentTimestamp()}&v=${package_json_1.version}`;\n        const payload = JSON.stringify(requestData);\n        const compressedPayload = lz_string_js_1.LZString.compressToBase64(payload);\n        const fetchOptions = {\n          method: 'POST',\n          mode: 'no-cors',\n          credentials: 'omit',\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n          },\n          body: `data=${encodeURIComponent(compressedPayload)}&compression=lz64`\n        };\n        try {\n          const rawResponse = yield postHogInstance.options.fetch(url, fetchOptions);\n          const body = yield rawResponse.text();\n        } catch (error) {\n          throw error;\n        }\n      });\n    }\n  };\n  return postHogInstance;\n}\nexports.createInternalPostHogInstance = createInternalPostHogInstance;","map":{"version":3,"mappings":"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","names":["defaultOptions","apiHost","maxQueueLength","optedIn","createInternalPostHogInstance","apiKey","options","globalThis","session","anonymousId","utils_1","postHogInstance","Object","distinctId","getDistinctId","getContextProperties","$lib","$lib_version","package_json_1","optIn","flush","optOut","capture","event","properties","enqueue","distinct_id","timestamp","context_1","identify","userProperties","$set","$anon_distinct_id","queue","apiRequest","push","length","makeRequest","events","requestData","api_key","batch","sent_at","url","payload","JSON","stringify","compressedPayload","lz_string_js_1","compressToBase64","fetchOptions","method","mode","credentials","headers","body","encodeURIComponent","rawResponse","fetch","text","error","exports"],"sources":["/Users/devaanshpatel02/Desktop/trial/ethsf2022-main/node_modules/posthog-js-lite/src/index.ts"],"sourcesContent":["import { version } from '../package.json'\nimport { PostHogAPIRequest, PostHogOptions, PostHogSession } from './types'\nimport { currentISOTime, currentTimestamp, generateUUID } from './utils/utils'\nimport { getContext } from './utils/context'\n\nimport { LZString } from './utils/lz-string.js'\n\nconst defaultOptions: PostHogOptions = {\n    apiHost: 'https://app.posthog.com',\n    maxQueueLength: 1,\n    optedIn: true,\n}\n\nexport function createInternalPostHogInstance(apiKey: string, options: PostHogOptions, globalThis: any) {\n    const session = {} as Partial<PostHogSession> // getDataFromCookiesAndLocalStorage\n    const anonymousId = generateUUID(globalThis)\n\n    let postHogInstance = {\n        options: { ...defaultOptions, ...options, apiKey } as Required<PostHogOptions>,\n\n        session: {\n            anonymousId: anonymousId,\n            distinctId: anonymousId,\n            ...session,\n        } as PostHogSession,\n\n        getDistinctId() {\n            return postHogInstance.session.distinctId\n        },\n\n        getContextProperties() {\n            return {\n                $lib: 'posthog-js-lite',\n                $lib_version: version,\n            }\n        },\n\n        optedIn() {\n            return postHogInstance.options.optedIn\n        },\n\n        optIn() {\n            postHogInstance.options.optedIn = true\n            postHogInstance.flush()\n        },\n\n        optOut() {\n            postHogInstance.options.optedIn = false\n        },\n\n        capture(event: string, properties = {}) {\n            postHogInstance.enqueue({\n                event,\n                distinct_id: postHogInstance.getDistinctId(),\n                timestamp: currentISOTime(),\n                properties: {\n                    ...getContext(globalThis), // TODO: debounce this, no need to do every event\n                    ...properties,\n                },\n            })\n        },\n\n        identify(distinctId: string | null, userProperties = {}) {\n            postHogInstance.enqueue({\n                event: '$identify',\n                distinct_id: distinctId || postHogInstance.session.anonymousId,\n                timestamp: currentISOTime(),\n                $set: {\n                    ...userProperties,\n                },\n                properties: {\n                    ...getContext(globalThis),\n                    $anon_distinct_id: postHogInstance.session.anonymousId,\n                },\n            })\n            if (distinctId) {\n                postHogInstance.session.distinctId = distinctId\n            }\n        },\n\n        queue: [] as PostHogAPIRequest[],\n        enqueue(apiRequest: PostHogAPIRequest) {\n            postHogInstance.queue.push(apiRequest)\n\n            if (postHogInstance.optedIn() && postHogInstance.queue.length >= postHogInstance.options.maxQueueLength) {\n                postHogInstance.flush()\n            }\n        },\n\n        flush() {\n            let queue = postHogInstance.queue\n            postHogInstance.queue = []\n            postHogInstance.makeRequest(queue)\n        },\n\n        makeRequest: async function (events: PostHogAPIRequest[]) {\n            const requestData = {\n                api_key: postHogInstance.options.apiKey,\n                batch: events,\n                sent_at: currentISOTime(),\n            }\n\n            const url = `${postHogInstance.options.apiHost}/e/?ip=1&_=${currentTimestamp()}&v=${version}`\n\n            const payload = JSON.stringify(requestData)\n            const compressedPayload = LZString.compressToBase64(payload)\n\n            const fetchOptions = {\n                method: 'POST',\n                mode: 'no-cors',\n                credentials: 'omit',\n                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n                body: `data=${encodeURIComponent(compressedPayload)}&compression=lz64`,\n            }\n\n            try {\n                const rawResponse = await postHogInstance.options.fetch(url, fetchOptions)\n                const body = await rawResponse.text()\n            } catch (error) {\n                // TODO: retry if fails?\n                throw error\n            }\n        },\n    }\n\n    return postHogInstance\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}